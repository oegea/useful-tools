"use strict";

var _ava = _interopRequireDefault(require("ava"));

var _net = _interopRequireDefault(require("net"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PORT_COUNT = 1000;

function isUnique(array) {
  const set = new Set();

  for (const element of array) {
    if (set.has(element)) {
      return false;
    }

    set.add(element);
  }

  return true;
}

function listen(server, port) {
  return new Promise((accept, reject) => {
    server.once('error', reject);
    server.listen(port, () => {
      accept(server.address().port);
    });
  });
}

function closeServer(server) {
  return new Promise((accept, reject) => {
    server.close(err => {
      if (err) {
        reject(err);
      } else {
        accept();
      }
    });
  });
}

(0, _ava.default)('findFreePorts() crashes properly when there are not enough free ports within the given range', async t => {
  await t.throwsAsync(() => (0, _index.findFreePorts)(10, {
    startPort: 65530
  }));
  await t.throwsAsync(() => (0, _index.findFreePorts)(3, {
    startPort: 1024,
    endPort: 1026
  }));
});
(0, _ava.default)('searches for one port by default', async t => {
  const ports = await (0, _index.findFreePorts)();
  t.assert(ports.length === 1);
  t.truthy(await (0, _index.isFreePort)(ports[0]));
});
(0, _ava.default)('can find a few ports when requested', async t => {
  const ports = await (0, _index.findFreePorts)(3);
  t.assert(ports.length === 3);
  t.assert(isUnique(ports));
});
(0, _ava.default)('can find a large amount of unique free ports', async t => {
  const ports = await (0, _index.findFreePorts)(PORT_COUNT);
  t.assert(ports.length === PORT_COUNT);
  t.truthy(isUnique(ports));
});
(0, _ava.default)('can run with only one job specified', async t => {
  const ports = await (0, _index.findFreePorts)(PORT_COUNT, {
    jobCount: 1
  });
  t.assert(ports.length === PORT_COUNT);
  t.truthy(isUnique(ports));
});
(0, _ava.default)('can run with exactly two jobs', async t => {
  const ports = await (0, _index.findFreePorts)(PORT_COUNT, {
    jobCount: 2
  });
  t.assert(ports.length === PORT_COUNT);
  t.truthy(isUnique(ports));
});
(0, _ava.default)('isFree() detects when a port is in use', async t => {
  t.plan(1);

  const server = _net.default.createServer();

  const port = await listen(server, undefined);
  t.falsy(await (0, _index.isFreePort)(port));
  await closeServer(server);
});
(0, _ava.default)('isFree() detects when a port is free', async t => {
  t.plan(1);

  const server = _net.default.createServer();

  const port = await listen(server);
  await closeServer(server);
  t.truthy(await (0, _index.isFreePort)(port));
});
//# sourceMappingURL=tests.js.map